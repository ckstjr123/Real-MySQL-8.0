# 9. 옵티마이저와 힌트

## 9.1 개요

### 9.1.2 옵티마이저의 종류
> 비용 기반 최적화: 쿼리를 처리하기 위한 여러가지 가능한 방법을 만들고,
  각 단위 작업 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.
  비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행한다.

---

## 9.2 기본 데이터 처리

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
- InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동으로 시작됨
  - 리드 어헤드란 디스크에서 미리 읽어 InnoDB의 버퍼 풀에 가져다 두는 것

### 9.2.3 ORDER BY 처리(Using filesort)
- 정렬 처리 방법
  - 인덱스를 이용한 정렬
  - Filesort

### 9.2.4 GROUP BY 처리
- GROUP BY 작업 또한 인덱스를 사용하는 경우와 그렇지 못한 경우로 나뉘며 인덱스를 사용하지 못하면 임시 테이블 사용

### 9.2.5 DISTINCT 처리
- 집합 함수가 없는 SELECT 쿼리에서 DISTINCT는 조회하는 모든 컬럼의 조합이 유니크한 레코드만 가져옴, COUNT() 또는 MIN()/MAX() 같은 집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 컬럼 조합이 유니크한 것들을 가져옴

---

## 9.3 고급 최적화

### 9.3.1 옵티마이저 스위치 옵션

#### 9.3.1.3 인덱스 컨디션 푸시다운(index_condition_pushdown)
- MySQL 5.5 버전가지는 인덱스를 범위 제한 조건으로 사용하지 못하는 조건은 MySQL 엔진이 스토리지 엔진으로 아예 전달해주지 않았음
- MySQL 5.6 버전부터는 인덱스를 범위 제한 조건으로 사용하지 못한다고 하더라도 인덱스에 포함된 컬럼의 조건이 있다면 스토리지 엔진으로 전달하도록 개선되었음

#### 9.3.1.4 인덱스 확장(use_index_extensions)
- InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 포함된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션

#### 9.3.1.5 인덱스 머지(index_merge)
- 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드 건수가 많을 것으로 예상될 때 인덱스 머지 실행 계획이 선택됨
  - 교집합(index_merge_intersection)
  - 합집합(index_merge_union)
  - 정렬 후 합집합(index_merge_sort_union)

#### 9.3.1.9 세미 조인(semijoin)
> 다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리.

- "IN (subquery)", "= (subquery)" 형태의 세미 조인 쿼리에 대한 최적화가 주로 적용됨
- 세미 조인 최적화 전략
  - 테이블 풀-아웃(Table Pull-out): 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후 쿼리를 조인 쿼리로 재작성하는 형태의 최적화
  - 중복 제거(Duplicate Weed-out): 세미 조인 서브쿼리를 일반적인 INNER JOIN 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리됨
  - 퍼스트 매치(First Match): IN(subquery) 형태의 세미 조인을 EXISTS(subquery) 형태로 튜닝한 것과 비슷한 방법으로 실행됨
  - 루즈 스캔(Loose Scan): 루즈 인덱스 스캔 방식을 사용함
  - 구체화(Materialization): 세미 조인에 사용된 서브쿼리를 통째로 구체화(내부 임시 테이블 생성)해서 쿼리를 최적화

#### 9.3.1.16 파생 테이블 머지(derived_merge)
- 옵티마이저가 자동으로 서브쿼리를 외부 쿼리로 병합할 수 없는 경우(가능하다면 외부 쿼리로 수동 병합해서 작성하는 것이 쿼리 성능 향상에 도움)
    - SUM() 또는 MIN()/MAX() 같은 집계 함수와 윈도우 함수가 사용된 서브쿼리
    - DISTINCT가 사용된 서브쿼리
    - GROUP BY나 HAVING이 사용된 서브쿼리
    - LIMIT이 사용된 서브쿼리
    - UNION 또는 UNION ALL을 포함하는 서브쿼리
    - SELECT 절에 사용된 서브쿼리
    - 값이 변경되는 사용자 변수가 사용된 서브쿼리

 
### 9.3.2 조인 최적화 알고리즘
- Exhaustive 검색 알고리즘
- Greedy 검색 알고리즘

---

## 9.4 쿼리 힌트
- 인덱스 힌트
- 옵티마이저 힌트

### 9.4.1 인덱스 힌트

#### 9.4.1.1 STRAIGHT_JOIN
- SELECT, UPDATE, DELETE 쿼리에서 여러 개의 테이블이 조인되는 경우 조인 순서를 고정하는 용도
- 일반 테이블끼리 조인: 양쪽 테이블 모두 조인 컬럼에 인덱스가 있거나 양쪽 테이블 모두 조인 컬럼에 인덱스가 없는 경우에는 레코드 건수가 적은 테이블을 드라이빙 테이블로 선택해주는 것이 좋으며, 그 이외의 경우에는 조인 컬럼에 인덱스가 없는 테이블을 드라이빙으로 선택하는 것이 좋음

#### 9.4.1.2 USE INDEX / FORCE INDEX / IGNORE INDEX
- USE INDEX: 가장 자주 사용되는 인덱스 힌트로서 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장
- FORCE INDEX
- IGNORE INDEX
